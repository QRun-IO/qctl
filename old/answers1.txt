OCI vs zip default

Answer: Default OCI. It aligns with infra tooling (registries, SBOMs, provenance, cosign) and standardizes promotion/rollback. Keep zip as a fallback for air-gapped/bare-metal or early dev loops.

⸻

Registry signature format

Answer: Use Sigstore/cosign for OCI artifacts (keyless flow, great UX). For templates/qBits, start with PGP (ubiquitous, easy to bootstrap) but plan a migration path to Sigstore for a unified trust story.

⸻

SemVer range behavior

Answer: Honor the lockfile first. Default resolver: preferLatestMinor: true (caret ranges float within minor), with a strict/hermetic mode that pins exact versions and fails on drift.

⸻

Template engine

Answer: Default Handlebars/Mustache for determinism and simplicity. Allow Freemarker behind a feature flag/profile for complex conditional logic. Document escape rules and partials.

⸻

YAML schema mechanism

Answer: Validate with JSON Schema (portable, great error messages). Use bespoke validators only for computed/derived fields and cross-field constraints that JSON Schema can’t express cleanly.

⸻

LLM providers and models

Answer: Default self-hosted provider (no network by default). Make providers pluggable; ship adapters for OpenAI/Anthropic/Azure. Require explicit opt-in + API key for cloud use. Provide sane model caps via config (e.g., token limits, rate ceilings).

⸻

Local redaction policy

Answer: Ship conservative defaults: **/*.pem, **/*.key, **/.ssh/**, **/.env*, **/secrets/**, tokens in common files (npmrc, piprc, gradle.properties). Redact by pattern before any prompt assembly or telemetry.

⸻

Auth flows

Answer: Default OAuth Device Flow (works in TTY/CI). Use loopback browser for desktop convenience when available. Add service accounts later for automation with scoped tokens. All flows land tokens in OS keychain by default.

⸻

Plugin signing and isolation

Answer: Require signed plugins by trusted keys; unsigned = blocked by default (overrideable with a scary flag). Load via isolated classloaders, minimal SPI surface, no reflective access by default. Record provenance in a plugin ledger.

⸻

Windows shell integration

Answer: Provide a PowerShell module for completion, publish via winget/Scoop. Ship signed PS scripts and set execution policy guidance. Include qctl completion powershell and qctl man install helpers.

⸻

Telemetry fields

Answer: Opt-in only. Collect the minimum: anonymized install ID, command_name, duration_ms, exit_code, version, os/arch. No arguments, paths, or env unless user flips an explicit “extended” flag.

⸻

SBOM scope

Answer: MVP: runtime-only SBOM to keep friction low. GA: full transitive SBOM (CycloneDX) for supply-chain attestation; publish alongside artifacts and attach to OCI manifests.

⸻

Cache eviction policy

Answer: LRU with a configurable max size (global default, profile-overridable). Also provide qctl cache ls, qctl cache prune, and qctl cache clean --all. Periodic background prune on command exit.

⸻

Self-update channels and policies

Answer: Default weekly auto-check on command use (jittered). Channels: stable (default) and beta. Enterprise controls: disable auto-check, pin channel/version, or mirror updates from an internal endpoint.
